#!/usr/bin/env python3

'''
Start: ./dnsserver -p 20200 -n cs5700cdn.example.com
Testing: dig @127.0.0.1 -p 20200 cs5700cdn.example.com
'''

import socket
import argparse
import asyncio
import struct
from typing import Optional, Tuple


from utils import process_monitor


class DNSServer:
    """
    A simple DNS server that listens on a UDP socket and responds to DNS queries.
    """

    def __init__(self, port: int, name: str) -> None:
        """
        Initialize the DNS server.

        Args:
            port: The port number on which to listen for DNS queries.
            name: The name of the DNS server.
        """

        # create a UDP socket for DNS server
        self.udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.name = name
        self.port = port
        self.replica_servers = [
                                "cdn-http1.5700.network",
                                "cdn-http2.5700.network",
                                "cdn-http3.5700.network",
                                "cdn-http4.5700.network",
                                "cdn-http5.5700.network",
                                "cdn-http6.5700.network",
                                "cdn-http7.5700.network",
                                ]
        try:
            host = '0.0.0.0'
            # bind the socket to the specified port and IP address
            self.udp_socket.bind((host, port))
        except socket.error as error:
            print('Error connecting to socket: ', error)
            raise error

    def recv(self) -> None:
        """
        Receive DNS queries on the UDP socket and send DNS responses.

        This method listens on the UDP socket for incoming DNS queries, resolves the queries
        to a pre-defined IP address, and sends DNS responses back to the clients.

        Returns:
            None.
        """
        print("Serving at port", self.port)

        async def dns_coroutine(data: Tuple[bytes, str]) -> None:
            """
            Asynchronous coroutine closure function that performs a DNS lookup operation.

            Args:
                data: Data tuple received from DNS UDP socket
            """
            # get the source address of the incoming data
            source = data[1]

            # pre-defined IP address to resolve DNS queries
            # Note: This is currently hard coded. Final submission will have find best ip address logic.
            # dns_resolved_ip = "50.116.39.110"
            dns_resolved_ip = self.find_closest_ip_address()

            # the DNS query received from the client
            dns_query = data[0]

            # create a DNS response packet
            response = self.create_dns_response(dns_query, dns_resolved_ip)

            if response:
                # send the DNS response back to the client
                self.udp_socket.sendto(response, source)

        while True:
            # receive data from the UDP socket
            data = self.udp_socket.recvfrom(1024)
            # skip empty data
            if not data:
                continue
            asyncio.run(dns_coroutine(data))

    def close(self) -> None:
        """Close the UDP socket.

        This method closes the UDP socket that was opened.
        """
        self.udp_socket.close()

    
    def create_dns_response(self, dns_query: bytes, resolved_ip_address: str) -> Optional[bytes]:
        """
        Create a DNS response packet for a given DNS query packet.

        """
        # Unpack the DNS query headers
        dns_query_headers = struct.unpack('!HHHHHH', dns_query[0:12])

        # Get the number of questions in the DNS query packet
        no_of_questions = dns_query_headers[2]

        # Hardcode number of questions answered to 1
        no_of_que_answered = 1

        # Start parsing the DNS query packet after the headers
        # i.e 12th index in dns query packet
        start = 12
        domain_name, end, query_type, query_class = self.parse_question_packet(
            dns_query[start:])

        # Check if the DNS query matches the DNS server name
        if self.name != domain_name.decode():
            # send refused response for all other DNS queries.
            return self.create_refused_response(dns_query)

        # Create the answer packet
        answers = self.create_answer_packet(
            resolved_ip_address, dns_query[start:start+end], query_type, query_class)

        # Create the response header and Return the DNS response packet
        header = dns_query[0:2] + b"\x81\x80" + \
            struct.pack('!HHHH', no_of_questions, no_of_que_answered, 0, 0)
        return header + answers

    def create_refused_response(self, dns_query: bytes) -> bytes:
        """Create a DNS response message with REFUSED response code.

        Args:
            dns_query: The original DNS query message.

        Returns:
            bytes: A DNS response message with REFUSED response code.
        """
        # Extract the transaction ID from the query
        transaction_id = struct.unpack('!H', dns_query[0:2])[0]

        # Create the response message with REFUSED response code
        response_message = struct.pack(
            '!HHHHHH', transaction_id, 0x8183, 0x0001, 0x0000, 0x0000, 0x0000)

        return response_message

    def parse_question_packet(self, field: bytes) -> Tuple[bytes, int, int, int]:
        """
        Parse a DNS question packet and extract the domain name, query type, 
        and query class.

        Args:
            field: The DNS question packet as a bytes object.

        Returns:
            A tuple containing the domain name, the length of the domain name, 
            the query type, and the query class.
        """
        domain_name = b""  # initialize domain name
        length_field = field[0]  # get the initial length field
        start = 1  # start parsing after the length field
        end = start + length_field  # calculate end position

        # While there are still characters to read in the domain name
        while length_field != 0:
            end = start + length_field  # calculate end position

            # If this is the first part of the domain name
            if not domain_name:
                domain_name = field[start:end]
            else:
                domain_name = domain_name + b'.' + field[start:end]

            start = end + 1  # move start position to the next length field
            length_field = field[end]  # get the next length field

        # Get the query type and query class fields
        query_type = struct.unpack('!H', field[end+1:end+3])[0]
        query_class = struct.unpack('!H', field[end+3:end+5])[0]

        # Return the domain name, length of the domain name, query type,
        # and query class as a tuple
        return domain_name, end + 5, query_type, query_class

    def find_closest_ip_address(self) -> str:
        """
        Find the HTTP server IP address that is closest to the client by computing the RTT
        for each IP address and selecting the IP address with the minimum RTT.

        Args:
            resolved_ip_addresses: A list of IP addresses of the HTTP servers.

        Returns:
            str: The IP address of the HTTP server that is closest to the client.
        """
        # Initialize the minimum RTT to a very large value
        min_rtt = float('inf')
        closest_ip_address = None

        # Ping each IP address and compute the RTT
        for ip_address in self.replica_servers:
            rtt = self._ping(ip_address)

            # If the RTT is smaller than the current minimum, update the minimum RTT
            # and the closest IP address
            if rtt is not None and rtt < min_rtt:
                min_rtt = rtt
                closest_ip_address = ip_address

        return closest_ip_address

    def _ping(self, ip_address):
        return 1

    def create_answer_packet(self, resolved_ip_address: str, query: bytes,
                             query_type: int, query_class: int):
        """
        Create a DNS answer packet with the resolved IP address.

        Args:
            ip_addr: The resolved IP address as a string.
            query: The DNS question packet as a bytes object.
            query_type: The query type as an integer.
            query_class: The query class as an integer.

        Returns:
            The DNS answer packet as a bytes object.
            :param resolved_ip_address:
        """
        ptr_field = b"\xc0\x0c"  # pointer to domain name field in question packet
        ttl = 2  # time-to-live (TTL) field in answer packet
        length = 4  # length of IP address field in answer packet
        octets = resolved_ip_address.split('.')  # split IP address into octets

        # Pack the answer packet fields using the specified format string
        answer_packet = query + ptr_field + struct.pack(
            '!HHLHBBBB', query_type, query_class, ttl, length,
            int(octets[0]), int(octets[1]), int(octets[2]), int(octets[3])
        )

        # Return the answer packet as a bytes object
        return answer_packet

@process_monitor
def main(port: int, name: str):
    """
    The entry point of the program.

    Args:
        port: The port number to listen on as an integer.
        name: The DNS server name as a string.
    """
    dns_server = None
    try:
        dns_server = DNSServer(port, name)
        # start listening for and responding to DNS queries
        dns_server.recv()
    except Exception as exp:
        if dns_server:
            dns_server.close()
        raise exp


if __name__ == "__main__":

    # specify the default port number and the cdn name
    DEFAULT_PORT = 20200
    DEFAULT_NAME = 'cs5700cdn.example.com'

    # Define the command line arguments
    parser = argparse.ArgumentParser(description="DNS Server arguments")

    parser.add_argument('-p', dest="port", action='store',
                        type=int, help="Port Number (default: %(default)s)", default=DEFAULT_PORT)

    parser.add_argument('-n', dest="name", action='store', type=str,
                        help="CDN-specific name (default: %(default)s)", default=DEFAULT_NAME)

    # Parse the arguments
    args = parser.parse_args()

    # Call the main method with the specified port and cdn name
    main(args.port, args.name)
